Iniciamos o projeto na pasta alura-books-server
npm init -y
instalamos o express
npm install express
fiz o procedimento para o github e criamos o primeiro arquivo
app.js e importamos o express
como ele não colocou o type:module no package.json usaremos o
este formato de importação em todo o projeto
const express = require("express")
logo na sequência ele cria um servidor chamando
const app = express()
vamos agora configurar nosso servidor
definimos uma porta
const port = 8000
e fazemos a primeira rota

app.get('/', (req, res) => {
    res.send("Beleza...")
})

e depois deixamos o servidor escutando na porta

app.listen(port, ()=>{
    console.log(`Escutando a porta ${port}`)
})

roda o projeto com node app.js

npm install nodemon para usar o hot reload com nodemon
coloquei "dev": "nodemon app.js" no scripts do package.json
para rodar agora, npm run dev

vamos trabalhar as rotas... criamos uma pasta rotas e um arquivo livro.js

Importamos Router do express e criamos uma instância para trabalhar

const { Router } = require("express")

const router = Router()

agora é só definir as rotas de livros aqui dentro

começamos de forma simples definindo um get para '/'
perceba que ainda não se falou sobre livros ainda...
isso vai acontecer no app.js
Assim está livro.js
const { Router } = require("express")

const router = Router()

router.get('/', (req, res) => {
    res.send("Beleza pura...")
})

module.exports = router

e assim está app.js

const express = require("express")
const rotaLivro = require("./rotas/livro")

const app = express()

app.use('/livros', rotaLivro)

const port = 8000

app.listen(port, ()=>{
    console.log(`Escutando a porta ${port}`)
})

define-se rotaLivro e com app.use('/livros', rotaLivro)
definimos que ela está associada a /livros....

massa demais...

Inicialmente vamos definir os demais métodos apenas retornando textos simples...
os métodos ficarão praticamente iguais...

const { Router } = require("express")

const router = Router()

router.get('/', (req, res) => {
    res.send("Usando o método get")
})

router.post('/', (req, res) => {
    res.send("Usando o método post")
})

router.patch('/', (req, res) => {
    res.send("Usando o método patch")
})

router.delete('/', (req, res) => {
    res.send("Usando o método delete")
})

module.exports = router

testamos com o postman e deu tudo certo

vamos usar try-catch para lidar com erros
vou mostrar aqui o get....
o throw new Error("teste") simula um erro... foi apenas para testar se devolve 0 500 mesmo...

router.get('/', (req, res) => {
    try {
        throw new Error("teste")
        res.send("Usando o método get")

    } catch (error) {
        res.status(500)
        res.send(error.message)
    }
})

Vai continuar sem ele...

router.get('/', (req, res) => {
    try {
        res.send("Usando o método get")

    } catch (error) {
        res.status(500)
        res.send(error.message)
    }
})


replicando para os demais metódos o try-catch

vamos agora criar controladores para separar as responsabilidades...

criamos a pasta controladores e nela um aquivo livro.js

cada função callback que está em rotas, será trazida para o controlador...

function getLivros (req, res) {
    try {
        res.send("Usando o método get")

    } catch (error) {
        res.status(500)
        res.send(error.message)
    }
}

function postLivro (req, res) {
    try {
        res.send("Usando o método post")

    } catch (error) {
        res.status(500)
        res.send(error.message)
    }
}

module.exports = {
    getLivros,
    postLivro
}

o rotas será simplificado...

const { Router } = require("express")
const { getLivros, postLivro, patchLivro, deleteLivro } = require("../controladores/livro")

const router = Router()

router.get('/', getLivros)

router.post('/', postLivro)

router.patch('/', patchLivro)

router.delete('/', deleteLivro)

module.exports = router

simples assim... excelente....

Vamos agora criar um livros.json que vai funcionar como bbanco de dados

[
    {
        "id": "1",
        "nome": "Livro irado"
    },
    {
        "id": "2",
        "nome": "Livro muito legal"
    }
]

vamos usar o fs para manipular arquivos

const fs = require("fs")

vamos usar o readFileSync para ler arquivos e o writeFileSync para escrever arquivos

Para isso vamos alterar os controladores e criar os serviços

o controlador ficou assim para o get

const fs = require("fs")

function getLivros (req, res) {
    try {
        const livros = JSON.parse(fs.readFileSync("livros.json"))
        res.send(livros)
    } catch (error) {
        res.status(500)
        res.send(error.message)
    }
}

Mas o controlador não deve ser responsável por ler o arquivo...
criaremos um serviço para fazer isso...

vamos criar a pasta servicos e um arquivo livro.js

vamos criar uma função para cada verbo http que usaremos
começando pelo getTodosLivros

const fs = require("fs")

function getTodosLivros() {
    return JSON.parse(fs.readFileSync("livros.json"))
}

module.exports = {
    getTodosLivros
}

O controlador agora chama essa função no serviço

o serviço é reponsável por ler o arquivo
o controlador é responsável por enviar erro ou sucesso

const { getTodosLivros } = require("../servicos/livro")

function getLivros (req, res) {
    try {
        const livros = getTodosLivros()
        res.send(livros)
    } catch (error) {
        res.status(500)
        res.send(error.message)
    }
}

